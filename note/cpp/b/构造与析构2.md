> 析构函数是一种特殊的成员函数
>
> 创建对象时自动调用，对对象的数据成员进行初始化
>
> 栈区创建的对象，生存期结束时自动调用析构造函数
>
> 堆区创建的对象，要显式调用`delete`释放对象并调用析构
>
> 全局对象构造先于`main`函数，析构晚于`main`函数

#### 目录

* 转换构造函数
* 赋值与初始化区别
* `explicit`

##### 转换构造函数

* > 构造函数作用
  >
  > * 初始化
  > * 类型转化（**转换构造（单参数）**）
  >
  > 带一个参数的构造
  >
  > * 普通构造（初始化）
  > * 转换构造（初始化、类型转化）

* ```c++
  int main()
  {
  	Test t(10);          // 带一个参数的构造，充当普通构造函数
      t = 20;              // 将20赋值给对象
                           // 1.调用转换构造函数将20这个整数转换成类类型（生成一个临时对象）
                           // 2.将临时对象赋值给t对象（调用=运算符）
      return 0;
  }
  ```

  * ![image-20211228001334625](%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%842.assets/image-20211228001334625.png)

* 编译器可将一个参数的构造函数隐式转换成转换构造函数

##### 赋值与初始化区别

* 初始化语句中等号不是运算符

  * `Test t = 10;`    `//等价于 Test t(10); =`不是运算符，表示初始化
  * `t = 20;`              `//赋值操作 调用转换构造`
  * `t = t2;`               // 赋值操作 `t.operator=(t2);`

* ```c++
  Test& Test::operator=(const Test& other)
  {
      cout<<"Test::operator="<<endl;
      if(this == &other)  // 防止t=t(相同对象)就不用做类型转化
      // if(*this == other)  // 防止不同对象，但内容相同，但需要重载==
          return *this;
      num_ = other.num_;
      return *this;
  }
  ```

  * 重载`=`号运算符

##### `explicit`显式构造对象

* 阻止编译器隐式转换`Test t = 10;`
  * 相当于禁止了转换构造
  * `Test t2; t=t2;`