#### 目录

* 拷贝构造函数
* 拷贝构造函数被调用的几种情况

##### 拷贝构造函数

* 功能：用**一个对象初始化另一个对象**

  * ```c++
    Test t(10);
    // 调用拷贝构造
    Test t2 = t;
    // 等价于下面
    Test t2(t);
    ```

* 声明：只有一个参数并且参数为该类对象的引用

  * `Test(const Test& other);`
  * 这里**引用对象形参**与**传入的实参**共享**内存空间**
    * 不会再构造一个对象
  * 这里必须是`&`引用，不然使用值传递，又要调用拷贝构造 造成递归调用

* 若类中没有说明拷贝构造函数，则系统自动生成一个缺省复制构造函数，作为该类的公有成员

##### 拷贝构造函数调用的几种情况

* 当**函数形参**是**类对象**时，调用函数时，进行形参与实参结合使用

  * 在内存建立一个**局部对象**，将实参**拷贝到新的对象**中。调用**拷贝构造函数**
  * 使用引用作为形参时，共享内存，不会调用拷贝构造函数
  * ![image-20211228113430612](%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%844.assets/image-20211228113430612.png)

* 当函数返回值是类对象，函数执行完成返回调用者使用

  * 需要建立一个临时对象，再将该临时对象返回给调用者

  * 不能直接返回局部对象：

    * 局部对象在离开建立其的函数时消亡，不能在返回调用函数后继续生存
    * 编译器会在调用函数的表达式中创建一个无名临时对象，其生存周期只在函数调用处的表达式中
    * `return`对象，是在调用拷贝构造函数将该对象的值拷贝到临时对象
      * 若返回的是变量，处理过程类似，只是不调用构造函数

  * ```c++
    Test TestFun3(const Test& t)
    {
    	return t;     // 调用拷贝构造返回一个临时对象赋值给接收者，无人接管时临时对象则自己消亡
    }
    
    int main()
    {
        Test t(10);
        // TestFun3(t);             // 无人接管该临时对象，马上消亡
        Test t2 = TestFun3(t);      // 使用t2来接管临时对象，则该临时对象直接实名，不会再自己消亡
        // Test& t2 = TestFun3(t);  // 使用引用来接管，不会马上消亡
    }
    ```

  * ```c++
    const Test& TestFun4(const Test& t)
    {
        // return const_cast<Test&>(t);    // 返回引用时，不会调用拷贝构造；直接将t的引用传给接收者，指向同一个对象
        return t;                    
    }
    
    int main()
    {
        Test t(10);
        Test t2 = TestFun4(t);  // 返回对象的引用给t2初始化，也要用拷贝构造
        // const Test& t2 = TestFun4(t);  // 返回的对象引用被引用接收，不会调用拷贝构造
    }
    ```
  
    

