#### 目录

* 多态
* 静态绑定与动态绑定
* 虚函数
* 虚表指针
* `object slicing`与虚函数
* `overload、override、overwrite`

##### 多态

* 面向对象程序设计重要特征之一
* 发出**同样消息**被**不同类型的对象**接收时可能导致完全**不同的行为**
  * 动物 移动行为 `move`
    * 鱼在水里游
    * 鸟在天上飞
    * 马在草原上跑
  * 调用同名函数导致不同行为
  * 一致的观点看待同一个类派生的对象，减轻分别设计的负担
* 多态实现
  * 函数重载
  * 运算符重载
  * 模板
  * **虚函数**（动态多态）

##### 静态绑定与动态绑定

* 静态绑定
  * 编译期间绑定，编译期就确定要调用的函数
* 动态绑定（虚函数）
  * 运行期绑定，运行时才确定要调用的函数

##### 虚函数

* 在**基类**中用`virtual`修饰的成员函数
* 定义
  * `virtual 函数类型 函数名称(参数列表);`
  * 若一个函数在**基类**中声明为**虚函数**，则其在**所有派生类中都是虚函数**
* 通过**基类指针**或**引用调用**虚函数才能引发动态绑定
  * ![image-20211228172425173](%E5%A4%9A%E6%80%811.assets/image-20211228172425173.png)
  * `Fun1`是虚函数，基类指针指向派生类对象，调用派生类对象的虚函数
  * `Fun3`**非虚**函数，**根据`p`指针实际类型调用相应类的成员函数**
* 虚函数**不能声明为静态**
  * 静态函数没有`this`指针，没办法取出对象头四个字节虚表

##### 虚析构函数

* 何时需要**虚析构**函数？
  * 若一个类要做多态基类，要将析构函数定义为虚析构
  * 通过基类指针删除派生类对象  内存泄露
  * 允许使用基类指针调用对象的析构函数（`detete`），被析构对象是有析构函数的派生类对象，需要使用基类虚析构函数

##### 虚表指针

* **虚函数动态绑定**通过**虚表**实现

* 包含虚函数的类   头4个字节存放**指向虚表的指针**

  * ![image-20211228202550646](%E5%A4%9A%E6%80%811.assets/image-20211228202550646.png)

  * ```c++
    typedef void (*FUNC)();
    int main()
    {
        Base b;
        long** p = (long**)&b;
        FUNC fun = (FUNC)p[0][0];   
        fun();                    // 调用Base::Fun1
        fun = (FUNC)p[0][1];
        fun();                    // 调用Base::Fun2
        return 0;
    }
    ```

##### `object slicing`对象切割与虚函数

* 向上转型
  * 派生类特有成员会丢失；**虚表也会发生变化，转化为基类对象**
    * 调用**拷贝构造函数**转换成基类对象
* ![image-20211228202946353](%E5%A4%9A%E6%80%811.assets/image-20211228202946353.png)

##### `overload、overwrite、override`

* 成员函数被重载
  * 相同范围（同一个类）
  * 函数名字相同
  * 参数不同
  * `virtual`关键字可有可无
* 覆盖是指派生类函数覆盖基类函数
  * 不同范围（分别在派生类与基类）
  * 函数名字相同
  * 参数相同
  * 基类函数必须有`virutal`关键字
* 重定义（派生类与基类）
  * 不同范围（分别位于派生类与基类）
  * 函数名与参数相同，无`virtual`关键字
  * 函数名相同，参数不同，`virtual`可有可无