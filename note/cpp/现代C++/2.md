> 智能指针：`RAII`资源管理功能的自然展现

```c++
class shape_wrapper {
public:
  explicit shape_wrapper(
    shape* ptr = nullptr)
    : ptr_(ptr) {}
  ~shape_wrapper()
  {
    delete ptr_;
  }
  shape* get() const { return ptr_; }

private:
  shape* ptr_;
};
```

* 能完成智能指针的基本功能：对超出作用域的对象进行释放
* **缺少**
  * 只适用于 `shape` 类
  * 类对象的行为不够像指针
  * 拷贝该类对象会引发程序行为异常

* 如何弥补？

##### 模板化和易用性

* 要使之能**包装任何类型的指针**，需要将其变成**类模板**

  * ```c++
    template <typename T>
    class smart_ptr {
    public:
      explicit smart_ptr(T* ptr = nullptr)
        : ptr_(ptr) {}
      ~smart_ptr()
      {
        delete ptr_;
      }
      T* get() const { return ptr_; }
    private:
      T* ptr_;
    };
    ```

  * 与 `shape_wrapper`对比，只是开头增加了模板声明 `template<typename T>`，然后吧代码中的 shape 替换成 模板参数 T 

* 模板使用

  * `shape_wrapper`  -->  `smart_ptr<shape>`  

* 与智能指针的差距

  * 不能用 * 运算符 解引用
  * 不能用 -> 运算符指向对象成员
  * 不能像指针一样用在布尔表达式中

* 解决方案

  * 加入成员函数

  * ```c++
    template <typename T>
    class smart_ptr {
    public:
      …
      T& operator*() const { return *ptr_; }
      T* operator->() const { return ptr_; }
      operator bool() const { return ptr_; }
    }
    ```

##### 拷贝构造与赋值

* 简称为拷贝

* 如何定义其行为

  * 示例代码

  * ```c++
    smart_ptr<shape> ptr1{create_shape(shape_type::circle)};
    smart_ptr<shape> ptr2{ptr1};
    ```

* 对于第二行，应该让其编译时出错，还是可以有一个合理的行为

  * 最简单情况：禁止拷贝

    * ```c++
      template <typename T>
      class smart_ptr {
        …
        smart_ptr(const smart_ptr&)
          = delete;
        smart_ptr& operator=(const smart_ptr&)
          = delete;
        …
      };
      ```

    * 禁用这两个函数非常简单，但却解决了一种可能出错的情况。

      * 不然`smart_ptr<shape> ptr2{ptr1};` 在编译时不会出错，但在运行时却会有未定义行为——由于会**对同一内存释放两次**，通常情况下会导致程序崩溃

    * 考虑在拷贝智能指针时把对象拷贝一份？

      * 使用智能指针的目的：减少对象的拷贝
      * 而且，指针类型是 shape ，但实际指向 circle 或 triangle 之类的子对象
        * C++ 中没有像 Java 的 clone 方法的约定
      * 一般来说，没有通用方法可以通过基类指针构造一个子类的对象

