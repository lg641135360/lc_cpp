##### 给定两个单词，计算从一个单词到另一个单词的最少操作数

* 可对一个单词进行如下操作
  * 插入一个字符
  * 删除一个字符
  * 替换一个字符

* 思考

  * 先考虑**最简单的情况**
    * 假设**字符串A和B都是空字符串**，那么很明显这个时候**编辑距离就是0**
    * 如果A增加一个字符`a1`，B保持不动，编辑距离就增加1
    * 如果B增加一个字符`b1`，A保持不动，编辑距离增加1
  * 如果A和B有一个字符，那么问题就有点复杂了
    * **插入字符**
      * A字符串是`a1`的时候，B空串增加一个字符变为`b1`
      * B字符串为`b1`的时候，A空串增加一个字符变为`a1`
      * 这种情况下，编辑距离都要增加1
    * **替换字符**
      * 当A和B都是空串的时候，同时增加一个字符
      * 如果要加入的字符`a1`和`b1`不相等，表示A和B之间转化的时候需要替换字符，那么编辑距离就是加1
      * 如果`a1`和`b1`相等，无需替换，那么编辑距离不变
  * 取上述**三种情况中编辑距离的最小值**作为**当前的编辑距离**
    * 编辑距离随着字符串的增长，是单调递增
    * 要求最终的最小值，必须要保证对于每个子串，都取得了最小值
    * 可以使用迭代的方式，一步步推导，直到两个字符串结束
    * 情况中没有删除，这是因为**删除就是插入的逆操作**
      * 如果我们**从完整的字符串A或者B开始**，而不是从空串开始，这就是**删除操作**
  * 可以将求编辑距离这个复杂的问题，划分为更多更小的子问题
    * 更为重要的一点是，我们在每一个子问题中，都**只需要保留一个最优解**
    * 之后的问题求解，只依赖这个最优值
    * 求编辑距离的方法就是动态规划，而这些子问题在动态规划中被称为不同的状态
  * ![image-20211006172043882](%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.assets/image-20211006172043882.png)

* 编程实现

  * 使用状态转移表来展示各个子串之间的关系，以及编辑距离的推导

  * |      | 空B  | m            | o            | u            | s            | e                |
    | ---- | ---- | ------------ | ------------ | ------------ | ------------ | ---------------- |
    | 空A  | 0    | 1            | 2            | 3            | 4            | 5                |
    | m    | 1    | min(2,2,0)=0 | min(3,1,2)=1 | min(4,2,3)=2 | min(5,3,4)=3 | min(6,4,5)=4     |
    | o    | 2    | min(1,3,2)=1 | min(2,3,0)=0 | min(3,1,2)=1 | min(4,2,3)=2 | min(5,3,4)=3     |
    | u    | 3    | min(2,4,3)=2 | min(1,3,2)=1 | min(2,2,0)=0 | min(3,1,2)=1 | min(4,2,3)=2     |
    | u    | 4    | min(3,5,4)=3 | min(2,4,3)=2 | min(1,3,1)=1 | min(2,2,1)=1 | min(3,2,2)=2     |
    | s    | 5    | min(4,6,5)=4 | min(3,5,4)=3 | min(2,4,3)=2 | min(2,3,1)=1 | min(3,2,2)=2     |
    | e    | 6    | min(4,7,6)=5 | min(4,6,5)=4 | min(3,5,4)=3 | min(2,4,3)=2 | **min(3,3,1)=1** |

  * 假设字符数组A[]和B[]分别表示字符串A和B，A[i]表示字符串A中第i个位置的字符，B[i]表示字符串B中第i个位置的字符

    * 二维数组d[,]表示刚刚用于推导的二维表格，而d[i,j]表示这张表格中第i行、第j列求得的最终编辑距离
    * 函数r(i, j)表示替换时产生的编辑距离
      * 两个字符相同则加0
      * 不同就加1
    * 如果A[i]和B[j]相同，函数的返回值为0，否则返回值为1

  * 用迭代来表达上述的推导过程

    * 如果i为0，且j也为0，那么d[i, j]为0
    * 如果i为0，且j大于0，那么d[i, j]为j
    * 如果i大于0，且j为0，那么d[i, j]为i
    * 如果i大于0，且 j大于0，那么d[i, j]=min(d[i-1, j] + 1, d[i, j-1] + 1, d[i-1, j-1] + r(i, j))
      * 这一步最关键，表达式表示的是动态规划中从上一个状态到下一个状态之间可能存在的一些变化，以及基于这些变化的最终决策结果
      * 将这种表达式称为**状态转移方程**

  * 有了状态转移方程，就可以很清晰地用数学的方式，来描述状态转移及其对应的决策过程，而且，有了状态转移方程，具体的编码其实就很容易

  * ```c++
    /**
        * @Description:	使用状态转移方程，计算两个字符串之间的编辑距离
        * @param word1-第一个字符串
        * @param word2-第二个字符串
        * @return int-两者之间的编辑距离
        */
        int minDistance(string word1, string word2) {
            if(word1.empty() && word2.empty()) return 0;
    
            // 初始化记录状态转移的二维表
            vector<vector<int>> d(word1.size()+1,vector<int>(word2.size()+1,0));
    
            // 若i为0，且j大于等于0，那么d[i,j]=j
            for(int j=0;j<=word2.size();++j)
                d[0][j] = j;
            
            // 如果i大于等于0，且j为0，那么d[i, j]为i
            for (int i = 0; i <= word1.size(); i++) 
                d[i][0] = i;
            
            // 实现状态转移方程
            for (int i = 0; i < word1.size(); i++) {
                for (int j = 0; j < word2.size(); j++) {
    
                    int r = 0;
                    if (word1[i] != word2[j]) {
                        r = 1;
                    } 
    
                    int first_append = d[i][j + 1] + 1;
                    int second_append = d[i + 1][j] + 1;
                    int replace = d[i][j] + r;
    
                    int min_ = min(first_append, second_append);
                    min_ = min(min_, replace);
                    d[i + 1][j + 1] = min_;
    
                }
            }
            return d[word1.size()][word2.size()];
        }
    ```

* ![image-20211006172236204](%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.assets/image-20211006172236204.png)

