# lc_cpp
记录在406用cpp实现leetcode中的题目。

#### 后面是C++学习笔记

* 引用 -- 别名 也是指针

* 内联函数（inline）

  * 函数被反复调用，调用函数产生的开销较大
  * 引入内联函数机制
    * 编译器处理对内联函数的调用语句时，将整个函数代码插入到调用语句处，不会产生调用函数的语句

* 函数重载（避免二义性）

  * 函数名相同，参数个数/参数类型各不相同

* 隐藏 -- 设置私有成员

  * 目的：强制对成员变量的访问一定要通过成员函数
  * 作用：方便在类中成员函数处定义中修改
  * 可访问范围（base = 类定义中）（出现次数和先后次序没有限制）
    * private：私有对象，只能在成员函数内访问
    * public：公有对象，可以在任何地方访问
    * protected：保护对象，todo
  * class定义类缺省为私有对象
  * struct定义类，缺省成员可访问范围为公有对象

* 构造函数（public）

  * 形式：名字与类名一致，可有参数，无返回值

  * 作用：初始化对象，给成员变量赋初值

  * 没写构造时，生成默认无参数构造函数（不做任何操作）

    * 定义了构造函数，编译器不生成默认构造函数
    * 对象生成时构造函数自动调用。对象生成，不能对其执行构造函数

  * 复制构造函数 -- 一个参数，对同类对象的引用X::X(X&)或X::X(const X&)

    * 用一个对象初始化同类的另一个对象

      ```c++
      Complex c2(c1);
      Complex c2=c1;
      ```

    * 某函数有一参数是类A的对象，函数被调用时，类A的复制构造函数也被调用

      ```c++
      void Func(A a1){ }
      int main(){
          A a2;
          Func(a2);
          return 0;
      }
      ```

    * 某函数返回值是类A的对象，函数返回时，A的复制构造函数被调用

      ```c++
      class A{
         public:
          	int v;
          	A(int n){ 
              	v = n;
              }
          	A(const A & a){
                  v = a.v;
                  cout<<"copy constructor called"<<endl;
              }
      };
      
      A Func(){
          A b(4);
          return b;
      }
      int main(){
          cout<<Func().v<<endl;
          return 0;
      }
      ```

  * 类型转换构造函数

    * 目的：类型自动转换

    * 特征：单参数，需要时，自动调用转换构造函数，建立无名临时对象（或临时变量）

      ```c++
      class A{
          public:
          	double real,imag;
          	A(int i){   // 类型转换构造函数
                  real = i;
                  imag = 0;
              }
      };
      int main(){
          A a1(7,8);
          A a2 =12;
          a1 = 9; // 9会被自动转换成一个临时A对象
          return 0;
      }
      
      case 2:
      class B{
          public:
          	double real,imag;
          	explicit B(int i){      // 显式类型转换构造函数
                  real = i;imag=0;
              }
      };
      int main(){
         
              ...
                  a1 = 9;  // error 此时9不能被自动转换成一个临时B对象
              ...
              
      }
      ```

  * 析构函数

    * 定义：名字与类名相同，前面加上'~'，无参与返回值，一个类最多一个析构
    * 作用：**每个**对象消亡自动调用。释放空间
    * 缺省析构函数什么都不做，定义之后编译器则不会自己生成

* this指针  指向成员函数所作用的对象

  * 静态成员函数中不能使用this函数
    * 静态成员函数不具体作用于某个对象
    * 静态成员函数的真实参数的个数，是程序中写出的参数个数

* 静态成员变量（函数）  本质  全局变量（函数）

  * 普通成员变量 每个对象都有一份 
    * 具体作用于某个对象
  * 静态成员变量 所有对象共享一份
    * sizeof运算符也不会计算静态成员变量
    * 不具体作用于某个对象
    * 不需要通过对象访问
      * 类名：：成员名
        * Test::print();
      * 对象名.成员名
        * Test t;
        * t.print();
      * 指针->成员名
        * Test *t = &r;
        * p->print();
      * 引用.成员名
        * Test &ref = t;
        * int n = ref.number;
  * 机制存在的目的：
    * 将某些类紧密相关的全局变量和函数写到类中，看起来像一个整体，易于维护和理解
      * 一个随时需要知道矩形总数和总面积的图形处理程序
      * 全局变量记录总数和总面积
        * 用静态成员将两个变量封装进类中，更容易理解和维护
  * 注意：
    * 静态成员函数中，不能访问非静态成员变量、不能调用非静态成员函数

* 封闭类（enclosing）
  * 有成员对象的类
  * 任何生成封闭类对象的语句，都要定义构造函数，初始化成员对象
  * 构造函数和析构函数的执行顺序
    * 对象生成时，先执行所有对象成员的构造函数，然后执行封闭类的构造函数
    * 对象成员的构造函数调用次序和对象成员在类中的说明次序一致，与它们在成员初始化列表中出现的次序无关
    * 封闭类的对象消亡时，先执行封闭类的析构函数，然后执行成员对象的析构函数。次序和构造函数的调用次序相反

* 友元 关系不能相互传递，不能继承（我的朋友的朋友不是我的朋友，我爸爸的朋友不是我的朋友），类中声明其友元，友元可以访问其类，但是该类不一定能访问其友元

  * 友元函数和友元类

    * 友元函数：一个类的友元函数可以访问该类的私有成员

      * 可以将一个类的成员函数（包括构造、析构函数）说明为另一个类的友元

    * 友元类：如果A是B的友元类，那么A的成员函数可以访问B的私有成员

      * ```c++
        class CCar{
        private:
        	int price;
        	friend class CDrive; // 声明CDriver为友元类
        };
        class CDriver{
        public:
        	CCar My Car;
        	void ModifyCar(){
        		myCar.price += 1000; // 此处访问友元的私有成员
        	}
        }
        ```

* 常量成员函数

  * 不希望某个对象的值被改变，可定义该对象时前面加上const关键字

  * ```c++
    const Sample Obj；// 常量对象
    Obj.SetValue();        // error  常量对象只能使用构造函数、析构函数和有const说明的函数
    ```

  * 类成员函数后加上const关键字，表示该成员函数为常量成员函数

    * 其内部不能改变属性的值，不能调用非常量成员函数

  * 若一个成员函数内没有调用非常量成员函数，也没有修改成员变量的值。最好设置为常量成员函数

  * ```c++
    class CTest{
    public:
    	bool GetData() const{
    		m_n1++;
    		return m_b2;
    	}
    private:
    	mutable int m_n1;     // 可以在const成员函数中修改的成员变量
    	bool m_b2;
    }
    ```



* 运算符重载
  * 预定义的运算符：只能用于基本数据类型运算：整型、实型、字符型和逻辑型
    * 数学中两个复数可以进行+-运算，但在c++中不行
      * 需要自己定义运算符进行运算
      * complex_a + complex_b
  * 重载目的：扩展C++中提供的运算符的适用范围，使之能作用于对象
  * 实质：函数重载
    * 普通函数重载 和 成员函数重载
    * 把含有运算符的表达式转换成对运算符函数的调用
    * 把运算符的操作数转换成运算符函数的参数
    * 运算符被多次重载时，根据实参的类型决定调用哪个运算符函数

